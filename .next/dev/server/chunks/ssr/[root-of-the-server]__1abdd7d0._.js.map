{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 28, "column": 0}, "map": {"version":3,"sources":["file:///home/sumit/Desktop/Productivity/lib/server/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { getDb } from \"@/lib/db\";\nimport type { User } from \"@/lib/types\";\nimport bcrypt from \"bcrypt\";\nimport { ObjectId } from \"mongodb\";\n\nasync function getUserCollection() {\n  const db = await getDb();\n  return db.collection<User>(\"users\");\n}\n\nexport async function login(email: string, password: string): Promise<User | null> {\n  const users = await getUserCollection();\n  const existingUser = await users.findOne({ email });\n\n  if (existingUser) {\n    // @ts-ignore\n    const passwordMatch = await bcrypt.compare(password, existingUser.password);\n    if (passwordMatch) {\n      const { password, _id, ...userWithoutPassword } = existingUser;\n      return {\n        id: _id.toString(),\n        ...userWithoutPassword,\n      } as User;\n    }\n  }\n  return null;\n}\n\nexport async function signup(email: string, password: string, name: string): Promise<User | null> {\n  const users = await getUserCollection();\n  const existingUser = await users.findOne({ email });\n\n  if (existingUser) {\n    return null;\n  }\n\n  const hashedPassword = await bcrypt.hash(password, 10);\n  const result = await users.insertOne({\n    _id: new ObjectId(),\n    email,\n    name,\n    password: hashedPassword,\n    provider: \"email\",\n    createdAt: new Date().toISOString(),\n  });\n\n  if (result.acknowledged) {\n    const newUser: User = {\n      id: result.insertedId.toString(),\n      email,\n      name,\n      provider: \"email\",\n      createdAt: new Date().toISOString(),\n    };\n    return newUser;\n  }\n\n  return null;\n}"],"names":[],"mappings":";;;;;;;IAYsB,QAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///home/sumit/Desktop/Productivity/lib/server/auth.ts"],"sourcesContent":["\"use server\";\n\nimport { getDb } from \"@/lib/db\";\nimport type { User } from \"@/lib/types\";\nimport bcrypt from \"bcrypt\";\nimport { ObjectId } from \"mongodb\";\n\nasync function getUserCollection() {\n  const db = await getDb();\n  return db.collection<User>(\"users\");\n}\n\nexport async function login(email: string, password: string): Promise<User | null> {\n  const users = await getUserCollection();\n  const existingUser = await users.findOne({ email });\n\n  if (existingUser) {\n    // @ts-ignore\n    const passwordMatch = await bcrypt.compare(password, existingUser.password);\n    if (passwordMatch) {\n      const { password, _id, ...userWithoutPassword } = existingUser;\n      return {\n        id: _id.toString(),\n        ...userWithoutPassword,\n      } as User;\n    }\n  }\n  return null;\n}\n\nexport async function signup(email: string, password: string, name: string): Promise<User | null> {\n  const users = await getUserCollection();\n  const existingUser = await users.findOne({ email });\n\n  if (existingUser) {\n    return null;\n  }\n\n  const hashedPassword = await bcrypt.hash(password, 10);\n  const result = await users.insertOne({\n    _id: new ObjectId(),\n    email,\n    name,\n    password: hashedPassword,\n    provider: \"email\",\n    createdAt: new Date().toISOString(),\n  });\n\n  if (result.acknowledged) {\n    const newUser: User = {\n      id: result.insertedId.toString(),\n      email,\n      name,\n      provider: \"email\",\n      createdAt: new Date().toISOString(),\n    };\n    return newUser;\n  }\n\n  return null;\n}"],"names":[],"mappings":";;;;;;;IA8BsB,SAAA,WAAA,GAAA,IAAA,+OAAA,EAAA,8CAAA,oOAAA,EAAA,KAAA,GAAA,0OAAA,EAAA"}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///home/sumit/Desktop/Productivity/lib/auth-context.tsx"],"sourcesContent":["\"use client\"\n\nimport { createContext, useContext, useState, useEffect, type ReactNode } from \"react\"\nimport type { User } from \"./types\"\nimport { login as serverLogin, signup as serverSignup } from \"./server/auth\"\n\ninterface AuthContextType {\n  user: User | null\n  isLoading: boolean\n  login: (email: string, password: string) => Promise<boolean>\n  signup: (email: string, password: string, name: string) => Promise<boolean>\n  loginWithProvider: (provider: \"google\" | \"facebook\" | \"github\") => Promise<boolean>\n  logout: () => void\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\nexport function AuthProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null)\n  const [isLoading, setIsLoading] = useState(true)\n\n  useEffect(() => {\n    // Check for existing session\n    const savedUser = localStorage.getItem(\"user\")\n    if (savedUser) {\n      setUser(JSON.parse(savedUser))\n    }\n    setIsLoading(false)\n  }, [])\n\n  const login = async (email: string, password: string): Promise<boolean> => {\n    const user = await serverLogin(email, password)\n    if (user) {\n      setUser(user)\n      localStorage.setItem(\"user\", JSON.stringify(user))\n      return true\n    }\n    return false\n  }\n\n  const signup = async (email: string, password: string, name: string): Promise<boolean> => {\n    const user = await serverSignup(email, password, name)\n    if (user) {\n      setUser(user)\n      localStorage.setItem(\"user\", JSON.stringify(user))\n      return true\n    }\n    return false\n  }\n\n  const loginWithProvider = async (provider: \"google\" | \"facebook\" | \"github\"): Promise<boolean> => {\n    // Simulate OAuth login - in production, this would redirect to OAuth provider\n    const mockUser: User = {\n      id: \"mock-user-id\",\n      email: `user@${provider}.com`,\n      name: `${provider.charAt(0).toUpperCase() + provider.slice(1)} User`,\n      provider,\n      createdAt: new Date().toISOString(),\n    }\n\n    setUser(mockUser)\n    localStorage.setItem(\"user\", JSON.stringify(mockUser))\n    return true\n  }\n\n  const logout = () => {\n    setUser(null)\n    localStorage.removeItem(\"user\")\n  }\n\n  return (\n    <AuthContext.Provider value={{ user, isLoading, login, signup, loginWithProvider, logout }}>\n      {children}\n    </AuthContext.Provider>\n  )\n}\n\nexport function useAuth() {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error(\"useAuth must be used within an AuthProvider\")\n  }\n  return context\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AAEA;AAAA;AAJA;;;;AAeA,MAAM,4BAAc,IAAA,sNAAa,EAA8B;AAExD,SAAS,aAAa,EAAE,QAAQ,EAA2B;IAChE,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,iNAAQ,EAAc;IAC9C,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,iNAAQ,EAAC;IAE3C,IAAA,kNAAS,EAAC;QACR,6BAA6B;QAC7B,MAAM,YAAY,aAAa,OAAO,CAAC;QACvC,IAAI,WAAW;YACb,QAAQ,KAAK,KAAK,CAAC;QACrB;QACA,aAAa;IACf,GAAG,EAAE;IAEL,MAAM,QAAQ,OAAO,OAAe;QAClC,MAAM,OAAO,MAAM,IAAA,8JAAW,EAAC,OAAO;QACtC,IAAI,MAAM;YACR,QAAQ;YACR,aAAa,OAAO,CAAC,QAAQ,KAAK,SAAS,CAAC;YAC5C,OAAO;QACT;QACA,OAAO;IACT;IAEA,MAAM,SAAS,OAAO,OAAe,UAAkB;QACrD,MAAM,OAAO,MAAM,IAAA,+JAAY,EAAC,OAAO,UAAU;QACjD,IAAI,MAAM;YACR,QAAQ;YACR,aAAa,OAAO,CAAC,QAAQ,KAAK,SAAS,CAAC;YAC5C,OAAO;QACT;QACA,OAAO;IACT;IAEA,MAAM,oBAAoB,OAAO;QAC/B,8EAA8E;QAC9E,MAAM,WAAiB;YACrB,IAAI;YACJ,OAAO,CAAC,KAAK,EAAE,SAAS,IAAI,CAAC;YAC7B,MAAM,GAAG,SAAS,MAAM,CAAC,GAAG,WAAW,KAAK,SAAS,KAAK,CAAC,GAAG,KAAK,CAAC;YACpE;YACA,WAAW,IAAI,OAAO,WAAW;QACnC;QAEA,QAAQ;QACR,aAAa,OAAO,CAAC,QAAQ,KAAK,SAAS,CAAC;QAC5C,OAAO;IACT;IAEA,MAAM,SAAS;QACb,QAAQ;QACR,aAAa,UAAU,CAAC;IAC1B;IAEA,qBACE,8OAAC,YAAY,QAAQ;QAAC,OAAO;YAAE;YAAM;YAAW;YAAO;YAAQ;YAAmB;QAAO;kBACtF;;;;;;AAGP;AAEO,SAAS;IACd,MAAM,UAAU,IAAA,mNAAU,EAAC;IAC3B,IAAI,YAAY,WAAW;QACzB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT"}}]
}